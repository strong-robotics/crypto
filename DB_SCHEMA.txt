многое сделано и вот что нужно обновить:

TOKENS
id
token_address
token_pair
name
symbol
icon
decimals
dev
token_program
circ_supply
total_supply
holder_count
usd_price
liquidity
fdv
mcap
price_block_id
organic_score
organic_score_label
pattern_code
mint_authority_disabled
freeze_authority_disabled
top_holders_percentage
dev_balance_percentage
blockaid_rugpull
pair_resolve_attempts
history_ready
created_at
token_updated_at

TOKENS_HISTORY — копия структуры TOKENS + поле archived_at, хранит архивные записи

sim_buy_token_amount - убрать
sim_buy_price_usd - убрать
sim_buy_iteration - убрать

sim_sell_token_amount - убрать
sim_sell_price_usd - убрать
sim_sell_iteration - убрать

sim_plan_sell_iteration - переименовать на plan_sell_iteration (это заполняет ИИ? правильно?)
sim_plan_sell_price_usd - переименовать на plan_sell_price_usd (это заполняет ИИ? правильно?)
sim_cur_income_price_usd - переименовать на cur_income_price_usd
sim_profit_usd - убрать

real_wallet_id - переименовать на wallet_id
sim_wallet_id - убрать и использовать wallet_id


TOKEN_METRICS_SECONDS
id
token_id
ts
usd_price
liquidity
fdv
mcap
price_block_id
jupiter_slot
holder_count
buy_count
sell_count
median_amount_sol
median_amount_usd
median_token_price
created_at
median_amount_tokens

TOKEN_METRICS_SECONDS_HISTORY — копия TOKEN_METRICS_SECONDS + поле archived_at

WALLET_HISTORY
id
wallet_id
token_id

entry_amount_usd
entry_token_amount
entry_price_usd
entry_iteration
entry_slippage_bps
entry_slippage_pct
entry_price_impact_pct
entry_transaction_fee_sol
entry_transaction_fee_usd
entry_expected_amount_usd
entry_actual_amount_usd
entry_signature

exit_token_amount
exit_price_usd
exit_amount_usd
exit_iteration
exit_signature
exit_slippage_bps
exit_slippage_pct
exit_price_impact_pct
exit_transaction_fee_sol
exit_transaction_fee_usd
exit_expected_amount_usd
exit_actual_amount_usd

profit_usd
profit_pct
outcome
reason
created_at
updated_at

TRADES_HISTORY — копия TRADES + поле archived_at

TRADE_ATTEMPTS (фиксирует удачные/неудачные force/auto buy/sell)
id
token_id
wallet_id
action            # auto_buy, force_buy, auto_sell, force_sell
status            # success, failed, skipped
message           # краткая причина/текст ошибки
details           # JSON с дополнительными полями (quote, signature и т.д.)
created_at

TRADES
id
token_id
signature
timestamp
readable_time
direction
amount_tokens
amount_sol
amount_usd
token_price_usd
slot
created_at

SIM_WALLETS - переименовать на WALLETS
id
name
cash_usd
entry_amount_usd
active_token_id
total_profit_usd
created_at
updated_at

AI_PATTERNS
id
code
name

AI_TOKEN_PATTERNS
id
token_id
pattern_id
confidence
source


многое сделано и вот обащая логика:

1) Сканер новых токенов получает список с Jupiter.
2) анализатор в несколько итераций с джупитер и фейлбек с декскринера заполняет таблицы токенов и только после этого они правильные попадают в нашу базу данных
3) Если мы не вошли в токен, то есть у нас в журнале покупок отсутствует данные про заход и там по моему у нас константа=20 итерацией цена и market cap нулевые значения, то мы этот токен тоже удаляем и всю его метрику понятное дело и все остальные данные которые есть по нему
4) Если мы вошли в токен, и точно так же у нас вот эти вот итерации возвращают пустые/нулевые значения по market cap и цене, то в этом случае мы закрываем сделку и записываем в журнал сделки просто нулевая цена освобождаем кошелек чтобы он мог дальше торговать мы не записываем транзакции мы не делаем транзакцию потому что вывели ликвидность вывели и jupiter однозначно вернет ошибку.
5) Модель искусственного интеллекта на 60-й секунде (есть константа/переменная специальная) должна дать свой прогноз, что это за паттерн. По каждому токену. 
6) Модель искусственного интеллекта после шестидесятой секунды каждый раз пересчитывает модель паттерна, и если он хороший, то на восьмидесятой секунде (есть константа/переменная специальная) у нас вход. В случае успешного входа на 80-й секунде мы записываем в журнал покупок и продаж вот эту автопокупку.
7) Если у нас произошла автопокупка, то анализатор ежесекундно, точнее как каждую итерацию, пересчитывает по курсу стоимость наших токенов. И если оно достигает профита в 15%, у нас срабатывает автопродажа. и все записывается в журнал продажи.
8) Если о прогнозу модели искусственного интеллекта мы не вышли на той секунде, которая нас прогнозировала, модель пересчитывает заново, когда может быть потенциальный выход. 
9) Также есть две функции ручной покупки и ручной продажи, которые идут отдельно от анализатора и срабатывают, когда пользователь нажимает две кнопки - купить или продать. И все записывается в журнал покупки и продажи.
10) Если я вручную купил токен, анализатор все равно пересчитывает как из автопокупкой ежесекундную итерацию по нашей цене текущей. Автопродажа может произойти раньше, чем я нажму выход из токена.
11) Все покупки и продажи происходят в модуле buy/sell. Анализатор только вызывает оттуда с того модуля необходимую автопродажу, если такая случилась.
12) Когда происходит автопокупка или автопродажа или ручная покупка или ручная продажа, то все записывается в журнал продаж и также оно должно добавлять или освобождать кошелек.
13) Баланс пересчитывается каждую итерацию по текущему состоянию саланы на каждом кошельке с текущей ценой, которую мы получаем с глобальной константы. И это должно быть отдельным параллельным потоком.
14) Функции, которые касаются покупки и продажи должны вызываться отдельным параллельным потоком, чтобы не блокировать все другие потоки.
15) У нас были поля симуляции, которые мы использовали во время разработки. Их мы больше не используем и мы должны их удалить. Мы все переходим в реальный журнал покупок и продаж.
16) В таблице покупок и продаж у нас уже есть все поля, которые отвечают за вход и выход. В таблице токена мы только оставляем планируемый выход из токена, который прогнозирует модель искусственного интеллекта. И те параметры, которые мы использовали для идентификации вошли или не вошли токен из таблицы токена, мы не используем, а начинаем использовать изистории окупок и продаж. Там есть токен ID и если у него есть entry amount количество токенов, значит мы вошли в этот токен.
17) Когда происходит автопродажа или ручная продажа, мы этот токен записываем в таблицу токенов с параметром history_ready true.
18) Если я нажимаю на кнопку выйти из токена, но мы не вошли в него, в этом случае мы удаляем токен и всю его метрику понятное дело и все остальные данные которые есть по нему
19) Надо записывать причину покупки в таблицу журнала что бы понимать почему не смогли купить


Где есть расхождения или серые зоны

Авто-вход не соответствует п.6. В конфиге AUTO_BUY_ENTRY_SEC = 10000080, и анализатор проверяет условие iterations >= entry_sec. То есть фактически вход никогда не наступит, пока не вернёшь 120. Сейчас UI-паттерн может быть «хороший», но покупка заблокирована самой константой.

Удаление токенов с нулями (п.3 и п.18). В DB_SCHEMA это описано, но в актуальном коде _v3_analyzer_jupiter.py нет явной процедуры, которая бы после «20 нулевых итераций» физически чистила tokens и token_metrics_seconds. finalize_token_sale() убирает токен только если была позиция; для невошедших пока ограничиваемся выставлением history_ready на плохих паттернах. Нужно или подтвердить, что чистилка есть в другом модуле (я не нашёл), или добавить.

Завершение сделки при нулевых метриках после входа (п.4). Частично реализовано: finalize_token_sale() ставит outcome='frozen' и нулевую цену, но триггерится она вручную из других частей (например, gap guard). Нет фонового процесса, который автоматически запускает это после N нулевых секунд; стоит проверить, что соответствующий вызов действительно идёт при обнулении цены.

П.8 («если не вышли вовремя»). ETA (ai/infer/eta_online.py) пересчитывает plan_sell_*, но анализатор пока не читает изменённый plan_sell_iteration для позиционных токенов — автопродажа завязана только на TARGET_RETURN и фактической цене. Прогнозные «выходы» служат подсказкой в UI, но не управляют сделкой.

П.10–11 (автопродажа для ручных входов и изоляция потоков). Журнал действительно общий: ручной вход → buy_real → все последующие проверки видят открытый wallet_history. Но отдельного параллельного потока нет: buy/sell запускаются внутри тех же async‑тасков. Если нагрузка вырастет, может блокировать анализатор, как и отмечалось в плане.

П.13 (баланс кошельков). Модуля, который бы «каждую итерацию пересчитывал баланс с учётом курса SOL», нет. В wallets поле cash_usd не обновляется автоматически; баланс по сути фиксированный. Это несоответствие плану.

П.14 (покупка/продажа в отдельном потоке). Сейчас buy_real/sell_real выполняются в том же event loop (см. вызовы в анализаторе). Если план подразумевал вынесение в отдельный worker, этого ещё нет.

П.17 (history_ready=true после продажи). Force/auto sell действительно выставляет history_ready, но если позиция не открывалась (например, ручной «Exit» по токену без entry), код просто ставит history_ready и всё. Удаления данных, как в п.18, не происходит.
